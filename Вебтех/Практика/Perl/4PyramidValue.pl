#!/usr/bin/perl

read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});
# Считываем из стандартного потока в буфер на длину, взятую из 
# переменной окружения CONTENT_LENGTH
@pairs = split(/&/, $buffer);  #Мы получаем строку вида arg1=val1&arg2=val2
foreach $pair (@pairs) {		#Поделили в массив и для каждой пары смотрим
  ($name, $value) = split(/=/, $pair);	
  #Делим на пару ключ-значение
  $value =~ tr/+/ /;					
  # Заменяем все + на пробелы (это если текст с пробелами в форму воткнули)
  # =~ здесь вызывает операцию с $value. Если бы стояло просто =, то 
  # операция была бы с общей переменной $_
  # tr от TRansliterate
  $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg; 
  #Каждый символ закодирован от %00 до %FF, декодируем обратно в норм текст
  # %([a-fA-F0-9][a-fA-F0-9]) закидывает в переменную $1
  # pack("C",hex($1) конвертирует в ASCII
  # e означает perl Expression, т.е. рассчитать правую часть для ->
  # -> g означает Globally, т.е. по всей строке, а не в первом вхождении
  $input{$name} = $value;   #Записываем в словарь по ключу name значение value
}

$A = $input{"A"};   #Вытаскиваем в новую переменную строку со стороной
$H = $input{"H"};   #Вытаскиваем в новую переменную строку с высотой

print "Content-type: text/html\n\n";
if ($A =~/^\d+(\.\d+)?$/ && $H =~/^\d+(\.\d+)?$/)	
#Здесь =~ это операция проверки по регэксу
#проверяем по маске, указано в комментариях к php версии
		{
			$A = $A * 1.0;   #Превращаем в дробное число
			$H = $H * 1.0;   #Превращаем в дробное число
			if ($A != 0 && $H != 0){
				$V = ($A ** 2) * $H / 3;
				print "<h3>Value: ", $V,"</h3>";  #Бабахаем объем
			}
			else
			{
				print "<h1>NO VALUE.</h1>";
			}
		}
		else
		{
			print "Bad number";
		}
print "\n";